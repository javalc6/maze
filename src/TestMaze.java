/*building and testing mazes without using recursive functions

version 1.0, 01-11-2022, only iterative methods (no recursion), mazes generated by this version are square mazes

build: javac TestMaze.java

usage: java TestMaze [size]

	optional parameter size must be an odd value greater than 3

Note: in this class a maze is an array of cells, each cell can be an empty place or a wall or a colored place (used to perform flooding and other tasks)

maze[] contains the following values:
0: empty place
1: wall
>=2: color (used to perform flooding and other tasks)
*/

import java.util.*;

public class TestMaze {

	final static int EMPTY = 0;
	final static int WALL = 1;

	public static void main (String[] args) {
		try {
			int maze_size = 51;
			if (args.length > 0) {
				maze_size = Integer.parseInt(args[0]);
			}
			TestMaze testMaze = new TestMaze();
			testMaze.test_maze(maze_size);
		} catch (java.lang.NumberFormatException | InvalidSizeException e) {
			System.out.println("usage: java TestMaze [size]");
			System.out.println("optional parameter size must be an odd value greater than 3");
			System.exit(1);
		}
	}
	
	public void test_maze(int maze_size) throws InvalidSizeException {
		Random random = new Random();
//out door shall be placed on the enclosure wall
		Point out_door = new Point(0, 1 + 2 * random.nextInt(maze_size / 2));
		Maze maze = new Maze(maze_size, out_door);
//inner cell is the typical place where a player is put at the beginning of a game
		Point inner_cell = maze.get_inner_cell();
//check if there are cells not connected to the out door
		System.out.println("Check cells reachability: " + maze.checkReachability(out_door));
//find a path from inner cell to out door
		ArrayList<Point> path = maze.findPathMaze(inner_cell, out_door);
//'color' path with value 2
		maze.setMaze(path, 2);
//show maze with exit path
		maze.printMaze();
		if (path.size() > 0)
			System.out.println("Length of shortest path="+path.size());
		else System.out.println("Error: there is no path between inner cell and out");
	}

	
	class Maze {
		final int N;//size of maze, including walls, must be an odd value greater than 3
		final int[][] maze;
		final Point inner_cell;
		final Random random = new Random();

//	buildMaze(): builds a maze
		public Maze(int n, Point out_door) throws InvalidSizeException {
			if ((n % 2 == 0) || (n < 5))
				throw new InvalidSizeException("Maze: n must be an odd value greater than 3");
			N = n;
			maze = new int[N][N]; //maze
	//build walls both horizontal and vertical
			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					if ((i % 2 == 0) || (j % 2 == 0))
						maze[i][j] = WALL;
					else maze[i][j] = EMPTY;
	//"extrude" blocks to form maze
			Stack<Point> queue = new Stack<>();
			int x = out_door.x + 1, y = out_door.y;
			Point point = new Point(x, y);
			queue.push(point);
			maze[x][y] = 2;
			while (!queue.empty()) {
				int i = point.x;
				int j = point.y;
				boolean found = false;

				int[] dirs = new int[4];
				// 4 random directions
				for (int k = 0; k < 4; k++) {
					dirs[k] = random.nextInt(4 - k);
					for (int l = 0; l < k; l++)
						if (dirs[k] == dirs[l])
							dirs[k]++;
					int dir = dirs[k];
					if ((dir == 0) && (i < N - 2) && (maze[i + 2][j] == 0)) {
						maze[++i][j] = 2;
						maze[++i][j] = 2;
						found = true;
						break;
					} else if ((dir == 1) && (j < N - 2) && (maze[i][j + 2] == 0)) {
						maze[i][++j] = 2;
						maze[i][++j] = 2;
						found = true;
						break;
					} else if ((dir == 2) && (i > 2) && (maze[i - 2][j] == 0)) {
						maze[--i][j] = 2;
						maze[--i][j] = 2;
						found = true;
						break;
					} else if ((j > 2) && (maze[i][j - 2] == 0)) {
						maze[i][--j] = 2;
						maze[i][--j] = 2;
						found = true;
						break;
					}
				}
				if (found) {
					point = new Point(i, j);
					queue.push(point);
				} else point = queue.pop();
			}
			setMaze(out_door, EMPTY);//out_door door
	//now find proper exit door, maximize distance
			int max = 2, target_i = -1, target_j = -1;
			floodMazeDistance(out_door);
			for (int i = 1; i < N - 1; i++) {
				for (int j = 1; j < N - 1; j++) {
					if (maze[i][j] > max) {
						max = maze[i][j];
						target_i = i;
						target_j = j;
					}
				}
			}
			inner_cell = new Point(target_i, target_j);
			clearMaze();
		}

//get_inner_cell(): returns the position of the inner cell, the typical place where a player is put at the beginning of a game
		public Point get_inner_cell() {
			return inner_cell;
		}

//	findPathMaze(): finds path between in and out
		public ArrayList<Point> findPathMaze(Point in, Point out) {
			floodMazeDistance(in);
			ArrayList<Point> path = new ArrayList<>();
			int dist = maze[out.x][out.y] - 1;
			Point point = out;
	//backtrack path
			while (dist > 1) {
				int i = point.x;
				int j = point.y;
				if ((i < N - 1) && (j > 0) && (maze[i + 1][j] == dist)) {
					point = new Point(i + 1, j);
					path.add(point);
					dist--;
				} else if ((i > 0) && (j < N - 1) && (maze[i][j + 1] == dist)) {
					point = new Point(i, j + 1);
					path.add(point);
					dist--;
				} else if ((i > 0) && (j > 0) && (maze[i - 1][j] == dist)) {
					point = new Point(i - 1, j);
					path.add(point);
					dist--;
				} else if ((i > 0) && (j > 0) && (maze[i][j - 1] == dist)) {
					point = new Point(i, j - 1);
					path.add(point);
					dist--;
				}
			}
			clearMaze();
			return path;
		}

//	checkReachability(): check if all empty cells are reachable starting from point in
		public boolean checkReachability(Point in) {
			floodMazeDistance(in);
			for (int i = 1; i < N - 1; i++) {
				for (int j = 1; j < N - 1; j++) {
					if (maze[i][j] == EMPTY)
						return false;
				}
			}
			return true;
		}

//	printMazeValues(): prints cell values
		public void printMazeValues() {
			for (int j = 0; j < N; j++) {
				for (int i = 0; i < N; i++)
					System.out.print(maze[i][j]);
				System.out.println();
			}
		}

//	printMaze(): prints maze using * and . characters
		public void printMaze() {
			for (int j = 0; j < N; j++) {
				for (int i = 0; i < N; i++)
					if (maze[i][j] == EMPTY) {
						System.out.print(" ");
					} else if (maze[i][j] == WALL) {
						System.out.print("*");
					} else System.out.print(".");
					
				System.out.println();
			}
		}

//	setMaze(): set val in cell located at point p
		public void setMaze(Point p, int val) {
			maze[p.x][p.y] = val;
		}
		
//	getMaze(): get val in cell located at point p
		public int getMaze(Point p) {
			return maze[p.x][p.y];
		}
		
//	setMaze(): set val along path
		public void setMaze(ArrayList<Point> path, int val) {
			for (Point p: path)
				maze[p.x][p.y] = val;
		}

//	clearMaze(): clear all cells different from WALL
		public void clearMaze() {
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++)
					if (maze[i][j] > WALL)
						maze[i][j] = EMPTY;
			}
		}
		
		private void floodMaze(int i, int j, int color) {
			if (maze[i][j] == EMPTY) {//free place?
				maze[i][j] = color;
				if ((i < N - 1) && (j > 0)) floodMaze(i + 1, j, color);
				if ((i > 0) && (j < N - 1)) floodMaze(i, j + 1, color);
				if ((i > 0) && (j > 0)) floodMaze(i - 1, j, color);
				if ((i > 0) && (j > 0)) floodMaze(i, j - 1, color);
			}
		}

		@SuppressWarnings("unchecked")
		private void floodMazeDistance(Point p) {
			clearMaze();
			int distance = 2;
			Stack<Point> nextwave = new Stack<>();
			nextwave.push(p);
			while (!nextwave.empty()) {
				Stack<Point> wave = (Stack<Point>) nextwave.clone();
				nextwave.clear();
				while (!wave.empty()) {
					p = wave.pop();
					int i = p.x;
					int j = p.y;
					if (maze[i][j] == EMPTY) {//free place?
						maze[i][j] = distance;
						if ((i < N - 1) && (j > 0)) nextwave.push(new Point(i + 1, j));
						if ((i > 0) && (j < N - 1)) nextwave.push(new Point(i, j + 1));
						if ((i > 0) && (j > 0)) nextwave.push(new Point(i - 1, j));
						if ((i > 0) && (j > 0)) nextwave.push(new Point(i, j - 1));
					}
				}
				distance++;
			}
		}
	}

	class Point {
		final int x;
		final int y;

		Point(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}

	class InvalidSizeException extends Exception {
		public InvalidSizeException(String s) {
			super(s);
		}
	}
}
		